/*! For license information please see 998.min.js.LICENSE.txt */
(this.webpackChunk_tsparticles_updater_wobble=this.webpackChunk_tsparticles_updater_wobble||[]).push([[998],{998:(e,a,s)=>{s.d(a,{WobbleUpdater:()=>l});var t=s(533);class n{constructor(){this.angle=50,this.move=10}load(e){e&&(void 0!==e.angle&&(this.angle=(0,t.setRangeValue)(e.angle)),void 0!==e.move&&(this.move=(0,t.setRangeValue)(e.move)))}}class o{constructor(){this.distance=5,this.enable=!1,this.speed=new n}load(e){if(e&&(void 0!==e.distance&&(this.distance=(0,t.setRangeValue)(e.distance)),void 0!==e.enable&&(this.enable=e.enable),void 0!==e.speed))if((0,t.isNumber)(e.speed))this.speed.load({angle:e.speed});else{const a=e.speed;void 0!==a.min?this.speed.load({angle:a}):this.speed.load(e.speed)}}}const i=2*Math.PI;class l{constructor(e){this.container=e}async init(e){const a=e.options.wobble;e.wobble=a?.enable?{angle:(0,t.getRandom)()*i,angleSpeed:(0,t.getRangeValue)(a.speed.angle)/360,moveSpeed:(0,t.getRangeValue)(a.speed.move)/10}:{angle:0,angleSpeed:0,moveSpeed:0},e.retina.wobbleDistance=(0,t.getRangeValue)(a?.distance??0)*this.container.retina.pixelRatio,await Promise.resolve()}isEnabled(e){return!e.destroyed&&!e.spawning&&!!e.options.wobble?.enable}loadOptions(e,...a){e.wobble||(e.wobble=new o);for(const s of a)e.wobble.load(s?.wobble)}async update(e,a){if(!this.isEnabled(e))return;const{updateWobble:t}=await s.e(103).then(s.bind(s,103));t(e,a)}}}}]);