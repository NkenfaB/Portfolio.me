/*! For license information please see 373.min.js.LICENSE.txt */
(this.webpackChunk_tsparticles_engine=this.webpackChunk_tsparticles_engine||[]).push([[373],{2373:(t,i,e)=>{e.d(i,{Particle:()=>u});var s=e(3635),o=e(8279),a=e(5084),n=e(2418),h=e(7788),r=e(7162),c=e(7326),l=e(9087),p=e(3893);const d=.5;function f(t){if(!(0,o.dB)(t.outMode,t.checkModes))return;const i=2*t.radius;t.coord>t.maxCoord-i?t.setCb(-t.radius):t.coord<i&&t.setCb(t.radius)}class u{constructor(t,i){this.container=i,this._calcPosition=(t,i,e,o=0)=>{for(const[,s]of t.plugins){const t=void 0!==s.particlePosition?s.particlePosition(i,this):void 0;if(t)return c.U.create(t.x,t.y,e)}const a=t.canvas.size,n=(0,s.mC)({size:a,position:i}),h=c.U.create(n.x,n.y,e),r=this.getRadius(),l=this.options.move.outModes,p=i=>{f({outMode:i,checkModes:["bounce"],coord:h.x,maxCoord:t.canvas.size.width,setCb:t=>h.x+=t,radius:r})},d=i=>{f({outMode:i,checkModes:["bounce"],coord:h.y,maxCoord:t.canvas.size.height,setCb:t=>h.y+=t,radius:r})};if(p(l.left??l.default),p(l.right??l.default),d(l.top??l.default),d(l.bottom??l.default),this._checkOverlap(h,o)){const i=1;return this._calcPosition(t,void 0,e,o+i)}return h},this._calculateVelocity=()=>{const t=(0,s.lQ)(this.direction).copy(),i=this.options.move;if("inside"===i.direction||"outside"===i.direction)return t;const e=(0,s.Id)((0,s.Gu)(i.angle.value)),o=(0,s.Id)((0,s.Gu)(i.angle.offset)),a={left:o-e*d,right:o+e*d};return i.straight||(t.angle+=(0,s.vd)((0,s.Cs)(a.left,a.right))),i.random&&"number"==typeof i.speed&&(t.length*=(0,s.sZ)()),t},this._checkOverlap=(t,i=0)=>{const e=this.options.collisions,o=this.getRadius();if(!e.enable)return!1;const n=e.overlap;if(n.enable)return!1;const h=n.retries;if(h>=0&&i>h)throw new Error(`${a.gK} particle is overlapping and can't be placed`);return!!this.container.particles.find((i=>(0,s.Sp)(t,i.position)<o+i.getRadius()))},this._getRollColor=t=>{if(!t||!this.roll||!this.backColor&&!this.roll.alter)return t;const i=this.roll.horizontal&&this.roll.vertical?2:1,e=this.roll.horizontal?Math.PI*d:0;return Math.floor(((this.roll.angle??0)+e)/(Math.PI/i))%2?this.backColor?this.backColor:this.roll.alter?(0,l.PL)(t,this.roll.alter.type,this.roll.alter.value):t:t},this._initPosition=t=>{const i=this.container,e=(0,s.Gu)(this.options.zIndex.value);this.position=this._calcPosition(i,t,(0,s.uZ)(e,0,i.zLayers)),this.initialPosition=this.position.copy();const a=i.canvas.size;switch(this.moveCenter={...(0,o.bt)(this.options.move.center,a),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=(0,s.Gk)(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=r.O.origin},this._engine=t}destroy(t){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const i=this.container,e=this.pathGenerator,s=i.shapeDrawers.get(this.shape);s?.particleDestroy?.(this);for(const[,e]of i.plugins)e.particleDestroyed?.(this,t);for(const e of i.particles.updaters)e.particleDestroyed?.(this,t);e?.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}async draw(t){const i=this.container,e=i.canvas;for(const[,s]of i.plugins)await e.drawParticlePlugin(s,this,t);await e.drawParticle(this,t)}getFillColor(){return this._getRollColor(this.bubble.color??(0,n.gW)(this.color))}getMass(){return this.getRadius()**2*Math.PI*d}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??(0,n.gW)(this.strokeColor))}async init(t,i,e,r){const c=this.container,l=this._engine;this.id=t,this.group=r,this.effectClose=!0,this.effectFill=!0,this.shapeClose=!0,this.shapeFill=!0,this.pathRotation=!1,this.lastPathTime=0,this.destroyed=!1,this.unbreakable=!1,this.rotation=0,this.misplaced=!1,this.retina={maxDistance:{}},this.outType="normal",this.ignoresResizeRatio=!0;const d=c.retina.pixelRatio,f=c.actualOptions,u=(0,p.x)(this._engine,c,f.particles),g=u.effect.type,y=u.shape.type,{reduceDuplicates:v}=u;this.effect=(0,o.wA)(g,this.id,v),this.shape=(0,o.wA)(y,this.id,v);const w=u.effect,b=u.shape;if(e){if(e.effect?.type){const t=e.effect.type,i=(0,o.wA)(t,this.id,v);i&&(this.effect=i,w.load(e.effect))}if(e.shape?.type){const t=e.shape.type,i=(0,o.wA)(t,this.id,v);i&&(this.shape=i,b.load(e.shape))}}this.effectData=function(t,i,e,s){const a=i.options[t];if(a)return(0,o.ZB)({close:i.close,fill:i.fill},(0,o.wA)(a,e,s))}(this.effect,w,this.id,v),this.shapeData=function(t,i,e,s){const a=i.options[t];if(a)return(0,o.ZB)({close:i.close,fill:i.fill},(0,o.wA)(a,e,s))}(this.shape,b,this.id,v),u.load(e);const C=this.effectData;C&&u.load(C.particles);const m=this.shapeData;m&&u.load(m.particles);const _=new h.o(l,c);_.load(c.actualOptions.interactivity),_.load(u.interactivity),this.interactivity=_,this.effectFill=C?.fill??u.effect.fill,this.effectClose=C?.close??u.effect.close,this.shapeFill=m?.fill??u.shape.fill,this.shapeClose=m?.close??u.shape.close,this.options=u;const P=this.options.move.path;this.pathDelay=(0,s.Gu)(P.delay.value)*a.X5,P.generator&&(this.pathGenerator=this._engine.getPathGenerator(P.generator),this.pathGenerator&&c.addPath(P.generator,this.pathGenerator)&&await this.pathGenerator.init(c)),c.retina.initParticle(this),this.size=(0,o.V0)(this.options.size,d),this.bubble={inRange:!1},this.slow={inRange:!1,factor:1},this._initPosition(i),this.initialVelocity=this._calculateVelocity(),this.velocity=this.initialVelocity.copy();this.moveDecay=1-(0,s.Gu)(this.options.move.decay);const z=c.particles;z.setLastZIndex(this.position.z),this.zIndexFactor=this.position.z/c.zLayers,this.sides=24;let D=c.effectDrawers.get(this.effect);D||(D=this._engine.getEffectDrawer(this.effect),D&&c.effectDrawers.set(this.effect,D)),D?.loadEffect&&await D.loadEffect(this);let k=c.shapeDrawers.get(this.shape);k||(k=this._engine.getShapeDrawer(this.shape),k&&c.shapeDrawers.set(this.shape,k)),k?.loadShape&&await k.loadShape(this);const x=k?.getSidesCount;x&&(this.sides=x(this)),this.spawning=!1,this.shadowColor=(0,n.tX)(this.options.shadow.color);for(const t of z.updaters)await t.init(this);for(const t of z.movers)await(t.init?.(this));await(D?.particleInit?.(c,this)),await(k?.particleInit?.(c,this));for(const[,t]of c.plugins)t.particleCreated?.(this)}isInsideCanvas(){const t=this.getRadius(),i=this.container.canvas.size,e=this.position;return e.x>=-t&&e.y>=-t&&e.y<=i.height+t&&e.x<=i.width+t}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const t of this.container.particles.updaters)t.reset?.(this)}}}}]);