/*! For license information please see 103.min.js.LICENSE.txt */
(this.webpackChunk_tsparticles_move_base=this.webpackChunk_tsparticles_move_base||[]).push([[103],{103:(i,e,t)=>{t.d(e,{applyDistance:()=>y,getProximitySpeedFactor:()=>d,initSpin:()=>x,move:()=>p,spin:()=>v});var n=t(533);const a=.5,s=0,o=1,c=60,l=0,r=.01;function y(i){const e=i.initialPosition,{dx:t,dy:o}=(0,n.getDistances)(e,i.position),c=Math.abs(t),l=Math.abs(o),{maxDistance:r}=i.retina,y=r.horizontal,p=r.vertical;if(!y&&!p)return;if(!((y&&c>=y)??!1)&&!((p&&l>=p)??!1)||i.misplaced){if((!y||c<y)&&(!p||l<p)&&i.misplaced)i.misplaced=!1;else if(i.misplaced){const t=i.position,a=i.velocity;y&&(t.x<e.x&&a.x<s||t.x>e.x&&a.x>s)&&(a.x*=-(0,n.getRandom)()),p&&(t.y<e.y&&a.y<s||t.y>e.y&&a.y>s)&&(a.y*=-(0,n.getRandom)())}}else i.misplaced=!!y&&c>y||!!p&&l>p,y&&(i.velocity.x=i.velocity.y*a-i.velocity.x),p&&(i.velocity.y=i.velocity.x*a-i.velocity.y)}async function p(i,e,t,a,l,r){await async function(i,e){const t=i.options,a=t.move.path;if(!a.enable)return;if(i.lastPathTime<=i.pathDelay)return void(i.lastPathTime+=e.value);const s=await(i.pathGenerator?.generate(i,e));s&&i.velocity.addTo(s);a.clamp&&(i.velocity.x=(0,n.clamp)(i.velocity.x,-o,o),i.velocity.y=(0,n.clamp)(i.velocity.y,-o,o));i.lastPathTime-=i.pathDelay}(i,r);const y=i.gravity,p=y?.enable&&y.inverse?-o:o;l&&t&&(i.velocity.x+=l*r.factor/(c*t)),y?.enable&&t&&(i.velocity.y+=p*(y.acceleration*r.factor)/(c*t));const v=i.moveDecay;i.velocity.multTo(v);const d=i.velocity.mult(t);y?.enable&&a>s&&(!y.inverse&&d.y>=s&&d.y>=a||y.inverse&&d.y<=s&&d.y<=-a)&&(d.y=p*a,t&&(i.velocity.y=d.y/t));const x=i.options.zIndex,h=(o-i.zIndexFactor)**x.velocityRate;d.multTo(h);const{position:u}=i;u.addTo(d),e.vibrate&&(u.x+=Math.sin(u.x*Math.cos(u.y)),u.y+=Math.cos(u.y*Math.sin(u.x)))}function v(i,e){const t=i.container;if(!i.spin)return;const n={x:"clockwise"===i.spin.direction?Math.cos:Math.sin,y:"clockwise"===i.spin.direction?Math.sin:Math.cos};i.position.x=i.spin.center.x+i.spin.radius*n.x(i.spin.angle),i.position.y=i.spin.center.y+i.spin.radius*n.y(i.spin.angle),i.spin.radius+=i.spin.acceleration;const s=Math.max(t.canvas.size.width,t.canvas.size.height),c=s*a;i.spin.radius>c?(i.spin.radius=c,i.spin.acceleration*=-o):i.spin.radius<l&&(i.spin.radius=l,i.spin.acceleration*=-o),i.spin.angle+=e*r*(o-i.spin.radius/s)}function d(i){return i.slow.inRange?i.slow.factor:o}function x(i){const e=i.container,t=i.options.move.spin;if(!t.enable)return;const a=t.position??{x:50,y:50},s={x:.01*a.x*e.canvas.size.width,y:.01*a.y*e.canvas.size.height},o=i.getPosition(),c=(0,n.getDistance)(o,s),l=(0,n.getRangeValue)(t.acceleration);i.retina.spinAcceleration=l*e.retina.pixelRatio;i.spin={center:s,direction:i.velocity.x>=0?"clockwise":"counter-clockwise",angle:i.velocity.angle,radius:c,acceleration:i.retina.spinAcceleration}}}}]);